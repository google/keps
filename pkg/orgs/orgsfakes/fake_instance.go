// Code generated by counterfeiter. DO NOT EDIT.
package orgsfakes

import (
	sync "sync"

	orgs "github.com/calebamiles/keps/pkg/orgs"
	settings "github.com/calebamiles/keps/pkg/settings"
)

type FakeInstance struct {
	ApiReviewDefaultBranchStub        func() string
	apiReviewDefaultBranchMutex       sync.RWMutex
	apiReviewDefaultBranchArgsForCall []struct {
	}
	apiReviewDefaultBranchReturns struct {
		result1 string
	}
	apiReviewDefaultBranchReturnsOnCall map[int]struct {
		result1 string
	}
	ApiReviewRepositoryStub        func() string
	apiReviewRepositoryMutex       sync.RWMutex
	apiReviewRepositoryArgsForCall []struct {
	}
	apiReviewRepositoryReturns struct {
		result1 string
	}
	apiReviewRepositoryReturnsOnCall map[int]struct {
		result1 string
	}
	ApiReviewRepositoryOwnerStub        func() string
	apiReviewRepositoryOwnerMutex       sync.RWMutex
	apiReviewRepositoryOwnerArgsForCall []struct {
	}
	apiReviewRepositoryOwnerReturns struct {
		result1 string
	}
	apiReviewRepositoryOwnerReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsRepositoryStub        func() string
	enhancementsRepositoryMutex       sync.RWMutex
	enhancementsRepositoryArgsForCall []struct {
	}
	enhancementsRepositoryReturns struct {
		result1 string
	}
	enhancementsRepositoryReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsRepositoryDefaultBranchStub        func() string
	enhancementsRepositoryDefaultBranchMutex       sync.RWMutex
	enhancementsRepositoryDefaultBranchArgsForCall []struct {
	}
	enhancementsRepositoryDefaultBranchReturns struct {
		result1 string
	}
	enhancementsRepositoryDefaultBranchReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsRepositoryOwnerStub        func() string
	enhancementsRepositoryOwnerMutex       sync.RWMutex
	enhancementsRepositoryOwnerArgsForCall []struct {
	}
	enhancementsRepositoryOwnerReturns struct {
		result1 string
	}
	enhancementsRepositoryOwnerReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsTrackingRepositoryStub        func() string
	enhancementsTrackingRepositoryMutex       sync.RWMutex
	enhancementsTrackingRepositoryArgsForCall []struct {
	}
	enhancementsTrackingRepositoryReturns struct {
		result1 string
	}
	enhancementsTrackingRepositoryReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsTrackingRepositoryDefaultBranchStub        func() string
	enhancementsTrackingRepositoryDefaultBranchMutex       sync.RWMutex
	enhancementsTrackingRepositoryDefaultBranchArgsForCall []struct {
	}
	enhancementsTrackingRepositoryDefaultBranchReturns struct {
		result1 string
	}
	enhancementsTrackingRepositoryDefaultBranchReturnsOnCall map[int]struct {
		result1 string
	}
	EnhancementsTrackingRepositoryOwnerStub        func() string
	enhancementsTrackingRepositoryOwnerMutex       sync.RWMutex
	enhancementsTrackingRepositoryOwnerArgsForCall []struct {
	}
	enhancementsTrackingRepositoryOwnerReturns struct {
		result1 string
	}
	enhancementsTrackingRepositoryOwnerReturnsOnCall map[int]struct {
		result1 string
	}
	IsAuthorizedStub        func(settings.Runtime) (bool, error)
	isAuthorizedMutex       sync.RWMutex
	isAuthorizedArgsForCall []struct {
		arg1 settings.Runtime
	}
	isAuthorizedReturns struct {
		result1 bool
		result2 error
	}
	isAuthorizedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeInstance) ApiReviewDefaultBranch() string {
	fake.apiReviewDefaultBranchMutex.Lock()
	ret, specificReturn := fake.apiReviewDefaultBranchReturnsOnCall[len(fake.apiReviewDefaultBranchArgsForCall)]
	fake.apiReviewDefaultBranchArgsForCall = append(fake.apiReviewDefaultBranchArgsForCall, struct {
	}{})
	fake.recordInvocation("ApiReviewDefaultBranch", []interface{}{})
	fake.apiReviewDefaultBranchMutex.Unlock()
	if fake.ApiReviewDefaultBranchStub != nil {
		return fake.ApiReviewDefaultBranchStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.apiReviewDefaultBranchReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) ApiReviewDefaultBranchCallCount() int {
	fake.apiReviewDefaultBranchMutex.RLock()
	defer fake.apiReviewDefaultBranchMutex.RUnlock()
	return len(fake.apiReviewDefaultBranchArgsForCall)
}

func (fake *FakeInstance) ApiReviewDefaultBranchCalls(stub func() string) {
	fake.apiReviewDefaultBranchMutex.Lock()
	defer fake.apiReviewDefaultBranchMutex.Unlock()
	fake.ApiReviewDefaultBranchStub = stub
}

func (fake *FakeInstance) ApiReviewDefaultBranchReturns(result1 string) {
	fake.apiReviewDefaultBranchMutex.Lock()
	defer fake.apiReviewDefaultBranchMutex.Unlock()
	fake.ApiReviewDefaultBranchStub = nil
	fake.apiReviewDefaultBranchReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) ApiReviewDefaultBranchReturnsOnCall(i int, result1 string) {
	fake.apiReviewDefaultBranchMutex.Lock()
	defer fake.apiReviewDefaultBranchMutex.Unlock()
	fake.ApiReviewDefaultBranchStub = nil
	if fake.apiReviewDefaultBranchReturnsOnCall == nil {
		fake.apiReviewDefaultBranchReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.apiReviewDefaultBranchReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) ApiReviewRepository() string {
	fake.apiReviewRepositoryMutex.Lock()
	ret, specificReturn := fake.apiReviewRepositoryReturnsOnCall[len(fake.apiReviewRepositoryArgsForCall)]
	fake.apiReviewRepositoryArgsForCall = append(fake.apiReviewRepositoryArgsForCall, struct {
	}{})
	fake.recordInvocation("ApiReviewRepository", []interface{}{})
	fake.apiReviewRepositoryMutex.Unlock()
	if fake.ApiReviewRepositoryStub != nil {
		return fake.ApiReviewRepositoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.apiReviewRepositoryReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) ApiReviewRepositoryCallCount() int {
	fake.apiReviewRepositoryMutex.RLock()
	defer fake.apiReviewRepositoryMutex.RUnlock()
	return len(fake.apiReviewRepositoryArgsForCall)
}

func (fake *FakeInstance) ApiReviewRepositoryCalls(stub func() string) {
	fake.apiReviewRepositoryMutex.Lock()
	defer fake.apiReviewRepositoryMutex.Unlock()
	fake.ApiReviewRepositoryStub = stub
}

func (fake *FakeInstance) ApiReviewRepositoryReturns(result1 string) {
	fake.apiReviewRepositoryMutex.Lock()
	defer fake.apiReviewRepositoryMutex.Unlock()
	fake.ApiReviewRepositoryStub = nil
	fake.apiReviewRepositoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) ApiReviewRepositoryReturnsOnCall(i int, result1 string) {
	fake.apiReviewRepositoryMutex.Lock()
	defer fake.apiReviewRepositoryMutex.Unlock()
	fake.ApiReviewRepositoryStub = nil
	if fake.apiReviewRepositoryReturnsOnCall == nil {
		fake.apiReviewRepositoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.apiReviewRepositoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) ApiReviewRepositoryOwner() string {
	fake.apiReviewRepositoryOwnerMutex.Lock()
	ret, specificReturn := fake.apiReviewRepositoryOwnerReturnsOnCall[len(fake.apiReviewRepositoryOwnerArgsForCall)]
	fake.apiReviewRepositoryOwnerArgsForCall = append(fake.apiReviewRepositoryOwnerArgsForCall, struct {
	}{})
	fake.recordInvocation("ApiReviewRepositoryOwner", []interface{}{})
	fake.apiReviewRepositoryOwnerMutex.Unlock()
	if fake.ApiReviewRepositoryOwnerStub != nil {
		return fake.ApiReviewRepositoryOwnerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.apiReviewRepositoryOwnerReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) ApiReviewRepositoryOwnerCallCount() int {
	fake.apiReviewRepositoryOwnerMutex.RLock()
	defer fake.apiReviewRepositoryOwnerMutex.RUnlock()
	return len(fake.apiReviewRepositoryOwnerArgsForCall)
}

func (fake *FakeInstance) ApiReviewRepositoryOwnerCalls(stub func() string) {
	fake.apiReviewRepositoryOwnerMutex.Lock()
	defer fake.apiReviewRepositoryOwnerMutex.Unlock()
	fake.ApiReviewRepositoryOwnerStub = stub
}

func (fake *FakeInstance) ApiReviewRepositoryOwnerReturns(result1 string) {
	fake.apiReviewRepositoryOwnerMutex.Lock()
	defer fake.apiReviewRepositoryOwnerMutex.Unlock()
	fake.ApiReviewRepositoryOwnerStub = nil
	fake.apiReviewRepositoryOwnerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) ApiReviewRepositoryOwnerReturnsOnCall(i int, result1 string) {
	fake.apiReviewRepositoryOwnerMutex.Lock()
	defer fake.apiReviewRepositoryOwnerMutex.Unlock()
	fake.ApiReviewRepositoryOwnerStub = nil
	if fake.apiReviewRepositoryOwnerReturnsOnCall == nil {
		fake.apiReviewRepositoryOwnerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.apiReviewRepositoryOwnerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepository() string {
	fake.enhancementsRepositoryMutex.Lock()
	ret, specificReturn := fake.enhancementsRepositoryReturnsOnCall[len(fake.enhancementsRepositoryArgsForCall)]
	fake.enhancementsRepositoryArgsForCall = append(fake.enhancementsRepositoryArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsRepository", []interface{}{})
	fake.enhancementsRepositoryMutex.Unlock()
	if fake.EnhancementsRepositoryStub != nil {
		return fake.EnhancementsRepositoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsRepositoryReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsRepositoryCallCount() int {
	fake.enhancementsRepositoryMutex.RLock()
	defer fake.enhancementsRepositoryMutex.RUnlock()
	return len(fake.enhancementsRepositoryArgsForCall)
}

func (fake *FakeInstance) EnhancementsRepositoryCalls(stub func() string) {
	fake.enhancementsRepositoryMutex.Lock()
	defer fake.enhancementsRepositoryMutex.Unlock()
	fake.EnhancementsRepositoryStub = stub
}

func (fake *FakeInstance) EnhancementsRepositoryReturns(result1 string) {
	fake.enhancementsRepositoryMutex.Lock()
	defer fake.enhancementsRepositoryMutex.Unlock()
	fake.EnhancementsRepositoryStub = nil
	fake.enhancementsRepositoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepositoryReturnsOnCall(i int, result1 string) {
	fake.enhancementsRepositoryMutex.Lock()
	defer fake.enhancementsRepositoryMutex.Unlock()
	fake.EnhancementsRepositoryStub = nil
	if fake.enhancementsRepositoryReturnsOnCall == nil {
		fake.enhancementsRepositoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsRepositoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepositoryDefaultBranch() string {
	fake.enhancementsRepositoryDefaultBranchMutex.Lock()
	ret, specificReturn := fake.enhancementsRepositoryDefaultBranchReturnsOnCall[len(fake.enhancementsRepositoryDefaultBranchArgsForCall)]
	fake.enhancementsRepositoryDefaultBranchArgsForCall = append(fake.enhancementsRepositoryDefaultBranchArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsRepositoryDefaultBranch", []interface{}{})
	fake.enhancementsRepositoryDefaultBranchMutex.Unlock()
	if fake.EnhancementsRepositoryDefaultBranchStub != nil {
		return fake.EnhancementsRepositoryDefaultBranchStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsRepositoryDefaultBranchReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsRepositoryDefaultBranchCallCount() int {
	fake.enhancementsRepositoryDefaultBranchMutex.RLock()
	defer fake.enhancementsRepositoryDefaultBranchMutex.RUnlock()
	return len(fake.enhancementsRepositoryDefaultBranchArgsForCall)
}

func (fake *FakeInstance) EnhancementsRepositoryDefaultBranchCalls(stub func() string) {
	fake.enhancementsRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsRepositoryDefaultBranchStub = stub
}

func (fake *FakeInstance) EnhancementsRepositoryDefaultBranchReturns(result1 string) {
	fake.enhancementsRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsRepositoryDefaultBranchStub = nil
	fake.enhancementsRepositoryDefaultBranchReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepositoryDefaultBranchReturnsOnCall(i int, result1 string) {
	fake.enhancementsRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsRepositoryDefaultBranchStub = nil
	if fake.enhancementsRepositoryDefaultBranchReturnsOnCall == nil {
		fake.enhancementsRepositoryDefaultBranchReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsRepositoryDefaultBranchReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepositoryOwner() string {
	fake.enhancementsRepositoryOwnerMutex.Lock()
	ret, specificReturn := fake.enhancementsRepositoryOwnerReturnsOnCall[len(fake.enhancementsRepositoryOwnerArgsForCall)]
	fake.enhancementsRepositoryOwnerArgsForCall = append(fake.enhancementsRepositoryOwnerArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsRepositoryOwner", []interface{}{})
	fake.enhancementsRepositoryOwnerMutex.Unlock()
	if fake.EnhancementsRepositoryOwnerStub != nil {
		return fake.EnhancementsRepositoryOwnerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsRepositoryOwnerReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsRepositoryOwnerCallCount() int {
	fake.enhancementsRepositoryOwnerMutex.RLock()
	defer fake.enhancementsRepositoryOwnerMutex.RUnlock()
	return len(fake.enhancementsRepositoryOwnerArgsForCall)
}

func (fake *FakeInstance) EnhancementsRepositoryOwnerCalls(stub func() string) {
	fake.enhancementsRepositoryOwnerMutex.Lock()
	defer fake.enhancementsRepositoryOwnerMutex.Unlock()
	fake.EnhancementsRepositoryOwnerStub = stub
}

func (fake *FakeInstance) EnhancementsRepositoryOwnerReturns(result1 string) {
	fake.enhancementsRepositoryOwnerMutex.Lock()
	defer fake.enhancementsRepositoryOwnerMutex.Unlock()
	fake.EnhancementsRepositoryOwnerStub = nil
	fake.enhancementsRepositoryOwnerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsRepositoryOwnerReturnsOnCall(i int, result1 string) {
	fake.enhancementsRepositoryOwnerMutex.Lock()
	defer fake.enhancementsRepositoryOwnerMutex.Unlock()
	fake.EnhancementsRepositoryOwnerStub = nil
	if fake.enhancementsRepositoryOwnerReturnsOnCall == nil {
		fake.enhancementsRepositoryOwnerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsRepositoryOwnerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepository() string {
	fake.enhancementsTrackingRepositoryMutex.Lock()
	ret, specificReturn := fake.enhancementsTrackingRepositoryReturnsOnCall[len(fake.enhancementsTrackingRepositoryArgsForCall)]
	fake.enhancementsTrackingRepositoryArgsForCall = append(fake.enhancementsTrackingRepositoryArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsTrackingRepository", []interface{}{})
	fake.enhancementsTrackingRepositoryMutex.Unlock()
	if fake.EnhancementsTrackingRepositoryStub != nil {
		return fake.EnhancementsTrackingRepositoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsTrackingRepositoryReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryCallCount() int {
	fake.enhancementsTrackingRepositoryMutex.RLock()
	defer fake.enhancementsTrackingRepositoryMutex.RUnlock()
	return len(fake.enhancementsTrackingRepositoryArgsForCall)
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryCalls(stub func() string) {
	fake.enhancementsTrackingRepositoryMutex.Lock()
	defer fake.enhancementsTrackingRepositoryMutex.Unlock()
	fake.EnhancementsTrackingRepositoryStub = stub
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryReturns(result1 string) {
	fake.enhancementsTrackingRepositoryMutex.Lock()
	defer fake.enhancementsTrackingRepositoryMutex.Unlock()
	fake.EnhancementsTrackingRepositoryStub = nil
	fake.enhancementsTrackingRepositoryReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryReturnsOnCall(i int, result1 string) {
	fake.enhancementsTrackingRepositoryMutex.Lock()
	defer fake.enhancementsTrackingRepositoryMutex.Unlock()
	fake.EnhancementsTrackingRepositoryStub = nil
	if fake.enhancementsTrackingRepositoryReturnsOnCall == nil {
		fake.enhancementsTrackingRepositoryReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsTrackingRepositoryReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryDefaultBranch() string {
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.Lock()
	ret, specificReturn := fake.enhancementsTrackingRepositoryDefaultBranchReturnsOnCall[len(fake.enhancementsTrackingRepositoryDefaultBranchArgsForCall)]
	fake.enhancementsTrackingRepositoryDefaultBranchArgsForCall = append(fake.enhancementsTrackingRepositoryDefaultBranchArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsTrackingRepositoryDefaultBranch", []interface{}{})
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.Unlock()
	if fake.EnhancementsTrackingRepositoryDefaultBranchStub != nil {
		return fake.EnhancementsTrackingRepositoryDefaultBranchStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsTrackingRepositoryDefaultBranchReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryDefaultBranchCallCount() int {
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.RLock()
	defer fake.enhancementsTrackingRepositoryDefaultBranchMutex.RUnlock()
	return len(fake.enhancementsTrackingRepositoryDefaultBranchArgsForCall)
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryDefaultBranchCalls(stub func() string) {
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsTrackingRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsTrackingRepositoryDefaultBranchStub = stub
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryDefaultBranchReturns(result1 string) {
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsTrackingRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsTrackingRepositoryDefaultBranchStub = nil
	fake.enhancementsTrackingRepositoryDefaultBranchReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryDefaultBranchReturnsOnCall(i int, result1 string) {
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.Lock()
	defer fake.enhancementsTrackingRepositoryDefaultBranchMutex.Unlock()
	fake.EnhancementsTrackingRepositoryDefaultBranchStub = nil
	if fake.enhancementsTrackingRepositoryDefaultBranchReturnsOnCall == nil {
		fake.enhancementsTrackingRepositoryDefaultBranchReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsTrackingRepositoryDefaultBranchReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryOwner() string {
	fake.enhancementsTrackingRepositoryOwnerMutex.Lock()
	ret, specificReturn := fake.enhancementsTrackingRepositoryOwnerReturnsOnCall[len(fake.enhancementsTrackingRepositoryOwnerArgsForCall)]
	fake.enhancementsTrackingRepositoryOwnerArgsForCall = append(fake.enhancementsTrackingRepositoryOwnerArgsForCall, struct {
	}{})
	fake.recordInvocation("EnhancementsTrackingRepositoryOwner", []interface{}{})
	fake.enhancementsTrackingRepositoryOwnerMutex.Unlock()
	if fake.EnhancementsTrackingRepositoryOwnerStub != nil {
		return fake.EnhancementsTrackingRepositoryOwnerStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.enhancementsTrackingRepositoryOwnerReturns
	return fakeReturns.result1
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryOwnerCallCount() int {
	fake.enhancementsTrackingRepositoryOwnerMutex.RLock()
	defer fake.enhancementsTrackingRepositoryOwnerMutex.RUnlock()
	return len(fake.enhancementsTrackingRepositoryOwnerArgsForCall)
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryOwnerCalls(stub func() string) {
	fake.enhancementsTrackingRepositoryOwnerMutex.Lock()
	defer fake.enhancementsTrackingRepositoryOwnerMutex.Unlock()
	fake.EnhancementsTrackingRepositoryOwnerStub = stub
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryOwnerReturns(result1 string) {
	fake.enhancementsTrackingRepositoryOwnerMutex.Lock()
	defer fake.enhancementsTrackingRepositoryOwnerMutex.Unlock()
	fake.EnhancementsTrackingRepositoryOwnerStub = nil
	fake.enhancementsTrackingRepositoryOwnerReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) EnhancementsTrackingRepositoryOwnerReturnsOnCall(i int, result1 string) {
	fake.enhancementsTrackingRepositoryOwnerMutex.Lock()
	defer fake.enhancementsTrackingRepositoryOwnerMutex.Unlock()
	fake.EnhancementsTrackingRepositoryOwnerStub = nil
	if fake.enhancementsTrackingRepositoryOwnerReturnsOnCall == nil {
		fake.enhancementsTrackingRepositoryOwnerReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.enhancementsTrackingRepositoryOwnerReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeInstance) IsAuthorized(arg1 settings.Runtime) (bool, error) {
	fake.isAuthorizedMutex.Lock()
	ret, specificReturn := fake.isAuthorizedReturnsOnCall[len(fake.isAuthorizedArgsForCall)]
	fake.isAuthorizedArgsForCall = append(fake.isAuthorizedArgsForCall, struct {
		arg1 settings.Runtime
	}{arg1})
	fake.recordInvocation("IsAuthorized", []interface{}{arg1})
	fake.isAuthorizedMutex.Unlock()
	if fake.IsAuthorizedStub != nil {
		return fake.IsAuthorizedStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.isAuthorizedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeInstance) IsAuthorizedCallCount() int {
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	return len(fake.isAuthorizedArgsForCall)
}

func (fake *FakeInstance) IsAuthorizedCalls(stub func(settings.Runtime) (bool, error)) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = stub
}

func (fake *FakeInstance) IsAuthorizedArgsForCall(i int) settings.Runtime {
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	argsForCall := fake.isAuthorizedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeInstance) IsAuthorizedReturns(result1 bool, result2 error) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = nil
	fake.isAuthorizedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInstance) IsAuthorizedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isAuthorizedMutex.Lock()
	defer fake.isAuthorizedMutex.Unlock()
	fake.IsAuthorizedStub = nil
	if fake.isAuthorizedReturnsOnCall == nil {
		fake.isAuthorizedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isAuthorizedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeInstance) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.apiReviewDefaultBranchMutex.RLock()
	defer fake.apiReviewDefaultBranchMutex.RUnlock()
	fake.apiReviewRepositoryMutex.RLock()
	defer fake.apiReviewRepositoryMutex.RUnlock()
	fake.apiReviewRepositoryOwnerMutex.RLock()
	defer fake.apiReviewRepositoryOwnerMutex.RUnlock()
	fake.enhancementsRepositoryMutex.RLock()
	defer fake.enhancementsRepositoryMutex.RUnlock()
	fake.enhancementsRepositoryDefaultBranchMutex.RLock()
	defer fake.enhancementsRepositoryDefaultBranchMutex.RUnlock()
	fake.enhancementsRepositoryOwnerMutex.RLock()
	defer fake.enhancementsRepositoryOwnerMutex.RUnlock()
	fake.enhancementsTrackingRepositoryMutex.RLock()
	defer fake.enhancementsTrackingRepositoryMutex.RUnlock()
	fake.enhancementsTrackingRepositoryDefaultBranchMutex.RLock()
	defer fake.enhancementsTrackingRepositoryDefaultBranchMutex.RUnlock()
	fake.enhancementsTrackingRepositoryOwnerMutex.RLock()
	defer fake.enhancementsTrackingRepositoryOwnerMutex.RUnlock()
	fake.isAuthorizedMutex.RLock()
	defer fake.isAuthorizedMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeInstance) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ orgs.Instance = new(FakeInstance)
