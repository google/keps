// Code generated by counterfeiter. DO NOT EDIT.
package settingsfakes

import (
	sync "sync"

	settings "github.com/calebamiles/keps/pkg/settings"
)

type FakeRuntime struct {
	CacheDirStub        func() string
	cacheDirMutex       sync.RWMutex
	cacheDirArgsForCall []struct {
	}
	cacheDirReturns struct {
		result1 string
	}
	cacheDirReturnsOnCall map[int]struct {
		result1 string
	}
	ContentRootStub        func() string
	contentRootMutex       sync.RWMutex
	contentRootArgsForCall []struct {
	}
	contentRootReturns struct {
		result1 string
	}
	contentRootReturnsOnCall map[int]struct {
		result1 string
	}
	IsSandboxedStub        func() bool
	isSandboxedMutex       sync.RWMutex
	isSandboxedArgsForCall []struct {
	}
	isSandboxedReturns struct {
		result1 bool
	}
	isSandboxedReturnsOnCall map[int]struct {
		result1 bool
	}
	PrincipalDisplayNameStub        func() string
	principalDisplayNameMutex       sync.RWMutex
	principalDisplayNameArgsForCall []struct {
	}
	principalDisplayNameReturns struct {
		result1 string
	}
	principalDisplayNameReturnsOnCall map[int]struct {
		result1 string
	}
	PrincipalEmailStub        func() string
	principalEmailMutex       sync.RWMutex
	principalEmailArgsForCall []struct {
	}
	principalEmailReturns struct {
		result1 string
	}
	principalEmailReturnsOnCall map[int]struct {
		result1 string
	}
	PrincipalGithubHandleStub        func() string
	principalGithubHandleMutex       sync.RWMutex
	principalGithubHandleArgsForCall []struct {
	}
	principalGithubHandleReturns struct {
		result1 string
	}
	principalGithubHandleReturnsOnCall map[int]struct {
		result1 string
	}
	TargetDirStub        func() string
	targetDirMutex       sync.RWMutex
	targetDirArgsForCall []struct {
	}
	targetDirReturns struct {
		result1 string
	}
	targetDirReturnsOnCall map[int]struct {
		result1 string
	}
	TokenPathStub        func() string
	tokenPathMutex       sync.RWMutex
	tokenPathArgsForCall []struct {
	}
	tokenPathReturns struct {
		result1 string
	}
	tokenPathReturnsOnCall map[int]struct {
		result1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRuntime) CacheDir() string {
	fake.cacheDirMutex.Lock()
	ret, specificReturn := fake.cacheDirReturnsOnCall[len(fake.cacheDirArgsForCall)]
	fake.cacheDirArgsForCall = append(fake.cacheDirArgsForCall, struct {
	}{})
	fake.recordInvocation("CacheDir", []interface{}{})
	fake.cacheDirMutex.Unlock()
	if fake.CacheDirStub != nil {
		return fake.CacheDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.cacheDirReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) CacheDirCallCount() int {
	fake.cacheDirMutex.RLock()
	defer fake.cacheDirMutex.RUnlock()
	return len(fake.cacheDirArgsForCall)
}

func (fake *FakeRuntime) CacheDirCalls(stub func() string) {
	fake.cacheDirMutex.Lock()
	defer fake.cacheDirMutex.Unlock()
	fake.CacheDirStub = stub
}

func (fake *FakeRuntime) CacheDirReturns(result1 string) {
	fake.cacheDirMutex.Lock()
	defer fake.cacheDirMutex.Unlock()
	fake.CacheDirStub = nil
	fake.cacheDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) CacheDirReturnsOnCall(i int, result1 string) {
	fake.cacheDirMutex.Lock()
	defer fake.cacheDirMutex.Unlock()
	fake.CacheDirStub = nil
	if fake.cacheDirReturnsOnCall == nil {
		fake.cacheDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.cacheDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) ContentRoot() string {
	fake.contentRootMutex.Lock()
	ret, specificReturn := fake.contentRootReturnsOnCall[len(fake.contentRootArgsForCall)]
	fake.contentRootArgsForCall = append(fake.contentRootArgsForCall, struct {
	}{})
	fake.recordInvocation("ContentRoot", []interface{}{})
	fake.contentRootMutex.Unlock()
	if fake.ContentRootStub != nil {
		return fake.ContentRootStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.contentRootReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) ContentRootCallCount() int {
	fake.contentRootMutex.RLock()
	defer fake.contentRootMutex.RUnlock()
	return len(fake.contentRootArgsForCall)
}

func (fake *FakeRuntime) ContentRootCalls(stub func() string) {
	fake.contentRootMutex.Lock()
	defer fake.contentRootMutex.Unlock()
	fake.ContentRootStub = stub
}

func (fake *FakeRuntime) ContentRootReturns(result1 string) {
	fake.contentRootMutex.Lock()
	defer fake.contentRootMutex.Unlock()
	fake.ContentRootStub = nil
	fake.contentRootReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) ContentRootReturnsOnCall(i int, result1 string) {
	fake.contentRootMutex.Lock()
	defer fake.contentRootMutex.Unlock()
	fake.ContentRootStub = nil
	if fake.contentRootReturnsOnCall == nil {
		fake.contentRootReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.contentRootReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) IsSandboxed() bool {
	fake.isSandboxedMutex.Lock()
	ret, specificReturn := fake.isSandboxedReturnsOnCall[len(fake.isSandboxedArgsForCall)]
	fake.isSandboxedArgsForCall = append(fake.isSandboxedArgsForCall, struct {
	}{})
	fake.recordInvocation("IsSandboxed", []interface{}{})
	fake.isSandboxedMutex.Unlock()
	if fake.IsSandboxedStub != nil {
		return fake.IsSandboxedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isSandboxedReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) IsSandboxedCallCount() int {
	fake.isSandboxedMutex.RLock()
	defer fake.isSandboxedMutex.RUnlock()
	return len(fake.isSandboxedArgsForCall)
}

func (fake *FakeRuntime) IsSandboxedCalls(stub func() bool) {
	fake.isSandboxedMutex.Lock()
	defer fake.isSandboxedMutex.Unlock()
	fake.IsSandboxedStub = stub
}

func (fake *FakeRuntime) IsSandboxedReturns(result1 bool) {
	fake.isSandboxedMutex.Lock()
	defer fake.isSandboxedMutex.Unlock()
	fake.IsSandboxedStub = nil
	fake.isSandboxedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRuntime) IsSandboxedReturnsOnCall(i int, result1 bool) {
	fake.isSandboxedMutex.Lock()
	defer fake.isSandboxedMutex.Unlock()
	fake.IsSandboxedStub = nil
	if fake.isSandboxedReturnsOnCall == nil {
		fake.isSandboxedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isSandboxedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeRuntime) PrincipalDisplayName() string {
	fake.principalDisplayNameMutex.Lock()
	ret, specificReturn := fake.principalDisplayNameReturnsOnCall[len(fake.principalDisplayNameArgsForCall)]
	fake.principalDisplayNameArgsForCall = append(fake.principalDisplayNameArgsForCall, struct {
	}{})
	fake.recordInvocation("PrincipalDisplayName", []interface{}{})
	fake.principalDisplayNameMutex.Unlock()
	if fake.PrincipalDisplayNameStub != nil {
		return fake.PrincipalDisplayNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.principalDisplayNameReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) PrincipalDisplayNameCallCount() int {
	fake.principalDisplayNameMutex.RLock()
	defer fake.principalDisplayNameMutex.RUnlock()
	return len(fake.principalDisplayNameArgsForCall)
}

func (fake *FakeRuntime) PrincipalDisplayNameCalls(stub func() string) {
	fake.principalDisplayNameMutex.Lock()
	defer fake.principalDisplayNameMutex.Unlock()
	fake.PrincipalDisplayNameStub = stub
}

func (fake *FakeRuntime) PrincipalDisplayNameReturns(result1 string) {
	fake.principalDisplayNameMutex.Lock()
	defer fake.principalDisplayNameMutex.Unlock()
	fake.PrincipalDisplayNameStub = nil
	fake.principalDisplayNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) PrincipalDisplayNameReturnsOnCall(i int, result1 string) {
	fake.principalDisplayNameMutex.Lock()
	defer fake.principalDisplayNameMutex.Unlock()
	fake.PrincipalDisplayNameStub = nil
	if fake.principalDisplayNameReturnsOnCall == nil {
		fake.principalDisplayNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.principalDisplayNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) PrincipalEmail() string {
	fake.principalEmailMutex.Lock()
	ret, specificReturn := fake.principalEmailReturnsOnCall[len(fake.principalEmailArgsForCall)]
	fake.principalEmailArgsForCall = append(fake.principalEmailArgsForCall, struct {
	}{})
	fake.recordInvocation("PrincipalEmail", []interface{}{})
	fake.principalEmailMutex.Unlock()
	if fake.PrincipalEmailStub != nil {
		return fake.PrincipalEmailStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.principalEmailReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) PrincipalEmailCallCount() int {
	fake.principalEmailMutex.RLock()
	defer fake.principalEmailMutex.RUnlock()
	return len(fake.principalEmailArgsForCall)
}

func (fake *FakeRuntime) PrincipalEmailCalls(stub func() string) {
	fake.principalEmailMutex.Lock()
	defer fake.principalEmailMutex.Unlock()
	fake.PrincipalEmailStub = stub
}

func (fake *FakeRuntime) PrincipalEmailReturns(result1 string) {
	fake.principalEmailMutex.Lock()
	defer fake.principalEmailMutex.Unlock()
	fake.PrincipalEmailStub = nil
	fake.principalEmailReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) PrincipalEmailReturnsOnCall(i int, result1 string) {
	fake.principalEmailMutex.Lock()
	defer fake.principalEmailMutex.Unlock()
	fake.PrincipalEmailStub = nil
	if fake.principalEmailReturnsOnCall == nil {
		fake.principalEmailReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.principalEmailReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) PrincipalGithubHandle() string {
	fake.principalGithubHandleMutex.Lock()
	ret, specificReturn := fake.principalGithubHandleReturnsOnCall[len(fake.principalGithubHandleArgsForCall)]
	fake.principalGithubHandleArgsForCall = append(fake.principalGithubHandleArgsForCall, struct {
	}{})
	fake.recordInvocation("PrincipalGithubHandle", []interface{}{})
	fake.principalGithubHandleMutex.Unlock()
	if fake.PrincipalGithubHandleStub != nil {
		return fake.PrincipalGithubHandleStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.principalGithubHandleReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) PrincipalGithubHandleCallCount() int {
	fake.principalGithubHandleMutex.RLock()
	defer fake.principalGithubHandleMutex.RUnlock()
	return len(fake.principalGithubHandleArgsForCall)
}

func (fake *FakeRuntime) PrincipalGithubHandleCalls(stub func() string) {
	fake.principalGithubHandleMutex.Lock()
	defer fake.principalGithubHandleMutex.Unlock()
	fake.PrincipalGithubHandleStub = stub
}

func (fake *FakeRuntime) PrincipalGithubHandleReturns(result1 string) {
	fake.principalGithubHandleMutex.Lock()
	defer fake.principalGithubHandleMutex.Unlock()
	fake.PrincipalGithubHandleStub = nil
	fake.principalGithubHandleReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) PrincipalGithubHandleReturnsOnCall(i int, result1 string) {
	fake.principalGithubHandleMutex.Lock()
	defer fake.principalGithubHandleMutex.Unlock()
	fake.PrincipalGithubHandleStub = nil
	if fake.principalGithubHandleReturnsOnCall == nil {
		fake.principalGithubHandleReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.principalGithubHandleReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) TargetDir() string {
	fake.targetDirMutex.Lock()
	ret, specificReturn := fake.targetDirReturnsOnCall[len(fake.targetDirArgsForCall)]
	fake.targetDirArgsForCall = append(fake.targetDirArgsForCall, struct {
	}{})
	fake.recordInvocation("TargetDir", []interface{}{})
	fake.targetDirMutex.Unlock()
	if fake.TargetDirStub != nil {
		return fake.TargetDirStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.targetDirReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) TargetDirCallCount() int {
	fake.targetDirMutex.RLock()
	defer fake.targetDirMutex.RUnlock()
	return len(fake.targetDirArgsForCall)
}

func (fake *FakeRuntime) TargetDirCalls(stub func() string) {
	fake.targetDirMutex.Lock()
	defer fake.targetDirMutex.Unlock()
	fake.TargetDirStub = stub
}

func (fake *FakeRuntime) TargetDirReturns(result1 string) {
	fake.targetDirMutex.Lock()
	defer fake.targetDirMutex.Unlock()
	fake.TargetDirStub = nil
	fake.targetDirReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) TargetDirReturnsOnCall(i int, result1 string) {
	fake.targetDirMutex.Lock()
	defer fake.targetDirMutex.Unlock()
	fake.TargetDirStub = nil
	if fake.targetDirReturnsOnCall == nil {
		fake.targetDirReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.targetDirReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) TokenPath() string {
	fake.tokenPathMutex.Lock()
	ret, specificReturn := fake.tokenPathReturnsOnCall[len(fake.tokenPathArgsForCall)]
	fake.tokenPathArgsForCall = append(fake.tokenPathArgsForCall, struct {
	}{})
	fake.recordInvocation("TokenPath", []interface{}{})
	fake.tokenPathMutex.Unlock()
	if fake.TokenPathStub != nil {
		return fake.TokenPathStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.tokenPathReturns
	return fakeReturns.result1
}

func (fake *FakeRuntime) TokenPathCallCount() int {
	fake.tokenPathMutex.RLock()
	defer fake.tokenPathMutex.RUnlock()
	return len(fake.tokenPathArgsForCall)
}

func (fake *FakeRuntime) TokenPathCalls(stub func() string) {
	fake.tokenPathMutex.Lock()
	defer fake.tokenPathMutex.Unlock()
	fake.TokenPathStub = stub
}

func (fake *FakeRuntime) TokenPathReturns(result1 string) {
	fake.tokenPathMutex.Lock()
	defer fake.tokenPathMutex.Unlock()
	fake.TokenPathStub = nil
	fake.tokenPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) TokenPathReturnsOnCall(i int, result1 string) {
	fake.tokenPathMutex.Lock()
	defer fake.tokenPathMutex.Unlock()
	fake.TokenPathStub = nil
	if fake.tokenPathReturnsOnCall == nil {
		fake.tokenPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.tokenPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeRuntime) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.cacheDirMutex.RLock()
	defer fake.cacheDirMutex.RUnlock()
	fake.contentRootMutex.RLock()
	defer fake.contentRootMutex.RUnlock()
	fake.isSandboxedMutex.RLock()
	defer fake.isSandboxedMutex.RUnlock()
	fake.principalDisplayNameMutex.RLock()
	defer fake.principalDisplayNameMutex.RUnlock()
	fake.principalEmailMutex.RLock()
	defer fake.principalEmailMutex.RUnlock()
	fake.principalGithubHandleMutex.RLock()
	defer fake.principalGithubHandleMutex.RUnlock()
	fake.targetDirMutex.RLock()
	defer fake.targetDirMutex.RUnlock()
	fake.tokenPathMutex.RLock()
	defer fake.tokenPathMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRuntime) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ settings.Runtime = new(FakeRuntime)
